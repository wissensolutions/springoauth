## oAuth2

### What is OAuth2?
OAuth2 is the version 2 of the OAuth protocol (also called framework).This protocol allows third-party applications to grant limited access to an HTTP service, 
either on behalf of a resource owner or by allowing the third-party application to obtain access on its own behalf. 
Access is requested by a client, it can be a website or a mobile application for example.

#### Basic knowledge
##### Roles

OAuth2 defines 4 roles :

* **Resource Owner** : generally yourself.
* **Resource Server**: server hosting protected data (for example Google hosting your profile and personal information).
* **Client**: application requesting access to a resource server (it can be your PHP website, a Javascript application or a mobile application).
* **Authorization Server**: server issuing access token to the client. This token will be used for the client to request the resource server. 
This server can be the same as the authorization server (same physical server and same application), and it is often the case.

##### Tokens

Tokens are random strings generated by the authorization server and are issued when the client requests them.
There are 2 types of token:

* **Access Token**: this is the most important because it allows the user data from being accessed by a third-party application. 
This token is sent by the client as a parameter or as a header in the request to the resource server. It has a limited lifetime, which is defined by the authorization server. 
It must be kept confidential as soon as possible but we will see that this is not always possible, especially when the client is a web browser that sends requests to the resource server via Javascript.
* **Refresh Token**: this token is issued with the access token but unlike the latter, it is not sent in each request from the client to the resource server.
 It merely serves to be sent to the authorization server for renewing the access token when it has expired. For security reasons, it is not always possible to obtain this token.

##### HTTPS

OAuth2 requires the use of HTTPS for communication between the client and the authorization server because of sensitive data passing between the two (tokens and possibly resource owner credentials). 
In fact you are not forced to do so if you implement your own authorization server but you must know that you are opening a big security hole by doing this.

## Spring MVC Security OAuth2 Example

### Prerequisite for run `authorization-server` and `resource-server`:
* Installed Maven Project environment

### Prerequisite for run `implicit-client`
* Installed [Node.js] (https://nodejs.org) and [npm] (https://www.npmjs.com/)
* Installed [bower-cli] (http://bower.io/)

### Build and Run :

* Run `authorization-server` and `resource-server` application :

    	execute `mvn clean tomcat7:run`

* Run `implicit-client` application, execute the following command :

        - execute `npm install`
        - execute `bower install`
        - execute `grunt`
		
		
### Grant Type : Resource Owner Password Credentials

##### When it should be used?
With this type of authorization, the credentials (and thus the password) are sent to the client and then to the authorization server. 
It is therefore imperative that there is absolute trust between these two entities. It is mainly used when the client has been developed by the same authority as the authorization server. 
For example, we could imagine a website named example.com seeking access to protected resources of its own subdomain api.example.com. 
The user would not be surprised to type his login/password on the site example.com since his account was created on it.

##### Example:
* **Resource Owner** : you having an account on abcd.com website of the Acme company
* **Resource Server**: Acme company exposing its API at api.abcd.com
* **Client**: abcd.com website from ABCD company
* **Authorization Server**: an ABCD server

##### Scenario:
Acme company, doing things well, thought to make available a RESTful API to third-party applications.
This company thinks it would be convenient to use its own API to avoid reinventing the wheel.
Company needs an access token to call the methods of its own API.
For this, company asks you to enter your login credentials via a standard HTML form as you normally would.
The server-side application (website abcd.com) will exchange your credentials against an access token from the authorization server (if your credentials are valid, of course).
This application can now use the access token to query its own resource server (api.abcd.com).

The following is how the Grant Type works in this application :

![alt text](resources/PasswordCredentials.png "Resource Owner Password Credentials")

* Request access token : 

        curl -X POST -vu clientapp:123456 http://localhost:8080/authorization-server/oauth/token -H "Accept: application/json" -d "client_id=clientapp&grant_type=password&username=admin&password=passw0rd" 

* `auth-server` will give you JSON response with access token :

		{
			"access_token":"9b3456a4-c5db-422e-a422-883a60bf1899",
			"token_type":"bearer",
			"expires_in":43199,
			"scope":"read write"
		}

* Access resource with header parameter : 

        curl -H "Authorization: Bearer 9b3456a4-c5db-422e-a422-883a60bf1899" http://localhost:8081/resource-server/api/admin

* `resource-server` will give JSON response :

		{
			"success":true,
			"page":"admin",
			"user":"admin"
		}



### Grant Type : Client Credentials

##### When it should be used?
This type of authorization is used when the client is himself the resource owner. There is no authorization to obtain from the end-user.

#####Example:
* **Resource Owner** : any website
* **Resource Server**: Google Cloud Storage
* **Client**: the resource owner
* **Authorization Server**: a Google server

##### Scenario:
A website stores its files of any kind on Google Cloud Storage.
The website must go through the Google API to retrieve or modify files and must authenticate with the authorization server.
Once authenticated, the website obtains an access token that can now be used for querying the resource server (Google Cloud Storage).
The following is how the Grant Type works in this application :

![alt text](resources/ClientCredentials.png "Client Credentials")

* Request token with header `client_id` and `client_secret` as Basic Authorization and with `client_id` and `grant_type` as parameters.

        curl -X POST -vu clientcred:123456 http://localhost:8080/authorization-server/oauth/token -H "Accept: application/json" -d "client_id=clientcred&grant_type=client_credentials"

* We will get JSON response :

        {
			"access_token":"67f262cb-55f6-4c60-a49e-ae0ab8a8438c",
			"token_type":"bearer",
			"expires_in":43199,
			"scope":"trust"
		}

* Access resource with header parameter :

        curl -H "Authorization: Bearer 67f262cb-55f6-4c60-a49e-ae0ab8a8438c" http://localhost:8081/resource-server/api/client

* If success, will get JSON response :

        {
            "sukses":true,
            "page":"client",
            "user":"clientcred"
        }        


### Grant Type : Authorization Code

##### When it should be used?

It should be used as soon as the client is a web server. It allows you to obtain a long-lived access token since it can be renewed with a refresh token (if the authorization server enables it).

###### Example:

* **Resource Owner**: you
* **Resource Server**: a Google server
* **Client**: any website
* **Authorization Server**: a Google server

##### Scenario:

* A website wants to obtain information about your Google profile.
* You are redirected by the client (the website) to the authorization server (Google).
* If you authorize access, the authorization server sends an authorization code to the client (the website) in the callback response.
* Then, this code is exchanged against an access token between the client and the authorization server.
* The website is now able to use this access token to query the resource server (Google again) and retrieve your profile data.

 
![alt text](resources/AuthorizationCode.png "Authorization Code ")

    
The following is how the Grant Type works in this application :

* Call this URL in browser : 

		http://localhost:8080/authorization-server/oauth/authorize?client_id=clientauthcode&response_type=code&redirect_uri=http://localhost:8081/resource-server/api/state/new

* You will redirected to login page, login with username=`admin` and password=`passw0rd` and choose approve radio button and click Autorize button.

* You will redirected to redirect uri with parameter code :

        http://localhost:8081/resource-server/api/state/new?code=CODE

* Exchange authorization code with access token with call request :

        curl -X POST -vu clientauthcode:123456 http://localhost:8080/authorization-server/oauth/token -H "Accept: application/json" -d "grant_type=authorization_code&code=CODE&redirect_uri=http://localhost:8081/resource-server/api/state/new"

* We will get JSON response :

        {
            "access_token":"xxxx",
            "token_type":"bearer",
            "refresh_token":"yyyyy",
            "expires_in":43199,
            "scope":"write read"
        }

* Take access token to access protection resource, e.g :

        curl http://localhost:8081/resource-server/api/admin?access_token=08664d93-41e3-473c-b5d2-f2b30afe7053

* In this case, `resource-server` will validation token to authorization :

        curl -X POST -vu clientauthcode:123456 http://localhost:8080/authorization-server/oauth/check_token?token=08664d93-41e3-473c-b5d2-f2b30afe7053

* You will get JSON response :

        {
            "aud": ["test"],
            "exp": 1444158090,
            "user_name": "admin",
            "authorities": "ADMIN",
            "client_id": "clientauthcode",
            "scope": ["read", "write"]
        }


* Finaly, you will get resource :

        {
			"success":true,
			"page":"admin",
			"user":"admin"
		}

* If access token expired, you can request refresh token :

        curl -X POST -vu clientauthcode:123456 http://localhost:8080/authorization-server/oauth/token -d "client_id=clientauthcode&grant_type=refresh_token&refresh_token=436761f1-2f26-412b-ab0f-bbf2cd7459c4"

* `auth-server` will give you JSON response and new access token :

        {
            "access_token":"e425cee6-7167-4eea-91c3-2706d01dab7f",
            "token_type":"bearer",
            "refresh_token":"436761f1-2f26-412b-ab0f-bbf2cd7459c4",
            "expires_in":43199,"scope":"write read"
        }


### Grant Type : Implicit

##### When it should be used?
It is typically used when the client is running in a browser using a scripting language such as Javascript. This grant type does not allow the issuance of a refresh token.

##### Example:
* **Resource Owner**: you
* **Resource Server**: a Facebook server
* **Client**: a website using AngularJS for example
* **Authorization Server**: a Facebook server

##### Scenario:
The client (NodeJs) wants to obtain information about your Facebook profile.
You are redirected by the browser to the authorization server (Facebook).
If you authorize access, the authorization server redirects you to the website with the access token in the URI fragment (not sent to the web server). Example of callback: http://example.com/oauthcallback#access_token=MzJmNDc3M2VjMmQzN.
This access token can now be retrieved and used by the client (AngularJS) to query the resource server (Facebook). Example of query: https://graph.facebook.com/me?access_token=MzJmNDc3M2VjMmQzN.

The following is how the Grant Type works in this application :

![alt text](resources/ImplicitGrant.png "Implicit")

* Generate random `state` variable :

        curl http://localhost:8081/resource-server/api/state/new
    This state variable will be save as session attribute in server, we will use it for verification in next step.

* Generate token with `state` variable :

        curl http://localhost:8080/authorization-server/oauth/authorize?client_id=jsclient&response_type=token&scope=write&state=STATE

* `auth-server` will redirected to login page.
* Login with username=`admin` and password=`passw0rd`
* After success login, `auth-server` will redirected to URL `http://localhost:8081/resource-server/api/state/verify` with additinal hash token :
    
	`http://localhost:8081/resource-server/api/state/verify#access_token=fdd3ed9d-f378-406b-9d23-13b36aad5128&token_type=bearer&state=d6b63cdb-bbf0-4232-b3a2-5855c1b12b1d&expires_in=86399`

* Access protected resource :

        curl http://localhost:8081/resource-server/api/admin?access_token=fdd3ed9d-f378-406b-9d23-13b36aad5128
	
	And You can access it with header parameter as `Authorization` :

        curl -H "Authorization: Bearer 667aadee-883c-439f-9f18-50ef77e3fad6" http://localhost:8081/resource-server/api/admin


### References
* [Spring Security Guides] (http://docs.spring.io/spring-security/site/docs/current/guides/html5/)
* [Spring OAuth2 Developer Guide] (http://projects.spring.io/spring-security-oauth/docs/oauth2.html)
* [IETF] (https://tools.ietf.org/html/rfc6749)
* [Endy Muhardin Github Page] (https://github.com/endymuhardin/belajar-springoauth2)
* [Arip  Github Page] (https://github.com/ariphidayat/springmvc-oauth2-example)
* [Johann Reinke] (http://www.bubblecode.net/en/2016/01/22/understanding-oauth2/)
